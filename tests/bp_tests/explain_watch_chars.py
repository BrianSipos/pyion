#!/usr/bin/python3

'''
# =====================================================================
# Explain the watch characters generated by an ION node
#
# .. Tip:: Watch character definition can be found in ``bprc``, 
#          ``ltprc``, ``cdfprc``, etc.
# .. Tip: To see help ``./explain_watch_chars.py -h``
#
# Parameters
# ----------
#   -n,  --nodes:      List of nodes to process
#   -fo, --filter-out: List of protocols to filter out
#   -fi, --filter-in:  List of protocols to include
#
# Usage
# -----
# root@ion_node1:~/ion-interface# ./explain_watch_chars.py
# root@ion_node1:~/ion-interface# ./explain_watch_chars.py -n 1
# root@ion_node1:~/ion-interface# ./explain_watch_chars.py -fo ltp cfdp
# root@ion_node1:~/ion-interface# ./explain_watch_chars.py > file.txt
#
# Author: Marc Sanchez Net
# Date:   01/08/2019
# Copyright (c) 2018, Jet Propulsion Laboratory.
#
# =====================================================================
'''

import argparse
from pathlib import Path
import sys

# =====================================================================
# === Watch character parser
# =====================================================================

all_wcs = {
    # Watch characters from ``bprc``
    'bp' : {
        'a': 'new bundle is queued for forwarding',
        'b': 'bundle is queued for transmission',
        'c': 'bundle is popped from its transmission queue',
        'm': 'custody acceptance signal is received',
        'w': 'custody of bundle is accepted',
        'x': 'custody of bundle is refused',
        'y': 'bundle is accepted upon arrival',
        'z': 'bundle is queued for delivery to an application',
        '~': 'bundle is abandoned (discarded) on attempt to forward it',
        '!': 'bundle is destroyed due to TTL expiration',
        '&': 'custody refusal signal is received',
        '#': 'bundle is queued for re-forwarding due to CL protocol failure',
        'j': 'bundle is placed in ‘‘limbo’’ for possible future re-forwarding',
        'k': 'bundle is removed from ‘‘limbo’’ and queued for re-forwarding',
        '$': 'bundle’s custodial retransmission timeout interval expired'
    }, 
    # Watch characters from ``ltprc``
    'ltp' : {
        'd': 'bundle appended to block for next session',
        'e': 'segment of block is queued for transmission',
        'f': 'block has been fully segmented for transmission',
        'g': 'segment popped from transmission queue',
        'h': 'positive ACK received for block, session ended',
        's': 'segment received',
        't': 'block has been fully received',
        '@': 'negative ACK received for block, segments retransmitted',
        '=': 'unacknowledged checkpoint was retransmitted',
        '+': 'unacknowledged report segment was retransmitted',
        '{': 'export session canceled locally (by sender)',
        '}': 'import session canceled by remote sender',
        '[': 'import session canceled locally (by receiver)',
        ']': 'export session canceled by remote receiver'
    },
    # Watch characters from ``cfdprc``
    'cfdp' : {
        'p': 'CFDP PDU transmitted',
        'q': 'CFDP PDU received'
    },
    # Watch characters from ``dtpcrc``
    'dtpc' : {
        'o': 'new aggregator created for profile and destination endpoint',
        '\\<': 'new ADU aggregation initiated',
        'r': 'application data item added to aggregation',
        '\\>': 'aggregation complete, outbound ADU created',
        '-': 'outbound ADU sent via BP',
        'l': 'ADU end-to-end acknowledgment sent',
        'm': 'ADU deleted due to TTL expiration',
        'n': 'ADU queued for retransmission',
        'i': 'inbound ADU collector created', 
        'u': 'inbound ADU received',
        'v': 'ADU sequence gap detected',
        '?': 'inbound ADU discarded',
        '*': 'ADU sequence gap deleted due to impending ADU TTL expiration'
    }
}

def _parse_watch_chars(wc, filtered_in, filtered_out):
    """ Parse a string of watch charaters. """
    # Initialize variables
    s = []

    # If filtered_in is provided, compute the filtered_out
    if filtered_in:
        filtered_out = set(all_wcs.keys()) - set(filtered_in)

    # Iterate over each character
    for c in wc:
        for protocol, p_wcs in all_wcs.items():
            # If this watch character is not in this protocol, skip
            if c not in p_wcs:
                continue

            # If this protocol is to be filtered out, skip
            if protocol in filtered_out:
                break

            # Create explanation
            s.append(' '.join(['{0: <5}'.format(protocol), \
                               '{0: <2}:'.format(c), p_wcs[c]]))
            break
        else:
            # If you reach here, this character was not parsed
            s.append(' '.join(['{0: <5}'.format('N/A'), \
                               '{0: <2}:'.format(c), 'UNKNOWN WATCH CHARACTER']))

    # Form the final string
    return '\n'.join(s)

# =====================================================================
# === Input Parser
# =====================================================================

def _get_cli_arguments():
    # Initialize the parser
    parser = argparse.ArgumentParser(description="Utility tool to parse \
                                                  ION's watch characters")

    # List all the nodes in this container
    nodes = [d.name for d in nodes_folder.iterdir() if d.is_dir()]

    # Add basic arguments
    parser.add_argument('-n', '--nodes', type=str, nargs='+', default=nodes, 
                        choices=nodes,
                        help='One or multiple nodes to process', 
                        required=False)

    # Add filter options. They are mutually exclusive
    group = parser.add_mutually_exclusive_group()
    group.add_argument('-fo', '--filter_out', type=str, nargs='+', default=[], 
                        choices=list(all_wcs.keys()),
                        help='One or multiple protocols to filter out of report',
                        required=False)
    group.add_argument('-fi', '--filter_in', type=str, nargs='+', default=[], 
                        choices=list(all_wcs.keys()),
                        help='One or multiple protocols to include in report',
                        required=False)

    # Parse and return the arguments
    return parser.parse_args()

def _trigger_parser(nodes_folder):
    # Get the command line arguments
    args = _get_cli_arguments()

    # For each node, parse the contents of ``nodeX.stdout``
    for n in args.nodes:
        # Get the file
        filename = list((nodes_folder/n).glob('*.stdout'))[0]

        # Print header
        print('#', '='*HEADER_CHARS, filename, '='*HEADER_CHARS)

        # Read all lines. The last one will contain the 
        # watch characters
        with filename.absolute().open('r') as f:
            wc = f.readlines()[-1]

        # If wc == 'Stopping ipnadmin.' then no watch characters
        if wc == 'Stopping ipnadmin.\n':
            print('No watch characters in {}'.format(filename))
        else:
            print(_parse_watch_chars(wc, filtered_in=args.filter_in,
                                         filtered_out=args.filter_out))

        # Leave empty line
        print('-'*int(3*HEADER_CHARS))
        print(' ')

# =====================================================================
# === MAIN
# =====================================================================

if __name__ == '__main__':

    # Define constants
    HEADER_CHARS = 25
    nodes_folder = Path('./nodes')

    # Trigger parsing process
    _trigger_parser(nodes_folder)